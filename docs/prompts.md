awesome job! please turn your detailed `UX Structure Plan` for the YouTube sponsorship workflow into an `UI Implementation Plan` using Shadcn-UI components. Update your plan document with the appropriate Shadcn-UI component to be used in the `UI structure` and where. And you should only write the name of the appropriate components to be used besides the structure nodes. Do not add the actual code yet. please use extensive online search to carefully research the correct Shadcn-UI component label to use for each node in the structure. Do not make up the Shadcn-UI component names. in the actual coding planning stage, we must be able to map each Shadcn-UI label to a working code snippet. please put on your deep-thinking hat to deeply and thoroughly explore carefully and systematically how to create the best Shadcn-UI components mapping for your `UI Structure Plan` based on the actual component labels in the actual current Shadcn-UI library. apply rigorous and meticulous methodology and approach to think, explore, then create a detailed execution plan, then create the actual mapping `UI Structure Tree to Shadcn-UI Mapping` document in markdown format. please to your utmost best to surprise with your brilliant design. thank you and good luck!

---
awesome job! please put on the same deep-thinking hat to deeply and thoroughly explore carefully and systematically to create a detailed and comprehensive `Project Requirements Document` in markdown document that matches your re-imagined implementation. then create an awesome `README.md` for the GitHub repository to host this project. this document will guide any new developer to build the whole codebase with confidence and accuracy, clear and logical description that gives no ambiguity to execute the coding. thank you and good luck!

use the same rigorous and meticulous approach to deeply re-imagine an equally awesome and comprehensive and informative `README.md` for the new GitHub repository at https://github.com/nordeim/Kanban-Board-Application.git  to host your re-imagined design. make your README so compelling that new contributors will be immediately attracted to this awesomely gorgeous e-commerce platform. use at least 4000 words for the `README/md` in markdown format, add the following sections at appropriate point / sequence:

1. add / update a section to show / describe the project codebase file hierarchy
2. add / update a section for a flowchart diagram to describe the interactions between various files and modules
3. add / update a section to list and describe the files in the codebase file hierarchy 
4. Current features implemented (partially or fully), Roadmap for suggested improvements divided into two sections, one for the immediate and one for the long-term goals.
5. Clear and detailed deployment guide starting from the GitHub repository

---
awesome job! now put on your deep-thinking hat to deeply explore a detailed and comprehensive execution plan to build the codebase based on your re-imagined `UI Implementation Mapping` and PRD documents. please break down your execution plan in logical phases, and for each phase, specify the goals and objectives and with a list of files to complete for that phase. specify in detail how each file should include - specify details like its interfaces (interaction with other files and modules) and its purpose.  include a checklist for each file to build. the execution plan should be so clear and logical that even a new developer can code it with accuracy and minimal error. plan carefully how you will structure the execution plan with integrated checklist and what details to include before finally create the execution plan in markdown format. please plan carefully then execute this task. please try your very best to re-imagine the wonderfully detailed and no-brainer execution plan. you are my best coding assistant and architect in the world. thank you and good luck!

---
awesome job! please use the same rigorous and meticulous approach to deeply think and thoroughly explore the best implementation option to create a complete database schema for your re-imagined PRD and execution plan. put on your deep thinking hat to carefully plan then execute to create a re-imagined database schema for Postgresql within ```sql and ``` tags. thank you and good luck!

---
awesome job! please use the same rigorous and meticulous approach to very carefully and systematically review the database schema design in the sql file  you just created. use line by line comparison to fully and very deeply understand the database design and structure, then put on your deep-thinking hat to deeply and thoroughly explore the best implementation option to create an accurate and complete prisma/schema.prisma file to fully and faithfully represent the database design in the sql file generated. please plan very carefully how your will create a complete representation in your carefully implemented prisma/schema.prisma. remember to use line by line comparison so as not to miss (omit) any part of the database schema represented by the sql file created earlier.

---
awesome job with the comprehensive execution plan! to kickstart the project, I need a scaffolding for the codebase. please use the same rigorous and meticulous approach to deeply and thoroughly explore for the best implementation option to create the complete updated version of the specified files in phase 1 of the comprehensive execution plan shared earlier. please carefully plan how to create the complete version of each of the files in phase 1 before proceeding cautiously. please put on your deep-thinking hat to deeply and thoroughly explore how to re-imagine the complete updated files specified in phase 1 of the comprehensive execution plan. thank you and good luck my very best coding assistant and expert in the world!

---
awesome job! yes, please put on the same deep-thinking hat to deeply and thoroughly explore carefully and systematically to create all the code files (exclude `prisma/schema.prisma` since it was created) as specified in phase 2 of the execution plan. please use the same rigorous and meticulous approach to deeply and thoroughly explore for the best implementation option to create the complete updated version of all the code files in phase 2 of the comprehensive execution plan shared earlier. please carefully plan how to create the complete version of each of the remaining files in phase 2 before proceeding cautiously. please put on your deep-thinking hat to deeply and thoroughly explore how to re-imagine the complete updated files specified in phase 2 of the comprehensive execution plan. thank you and good luck my very best coding assistant and expert in the world!

---
awesome job! please use the same rigorous and meticulous approach to very carefully and systematically review the database schema design in the sql file  you just created. use line by line comparison to fully and very deeply understand the database design and structure, then put on your deep-thinking hat to deeply and thoroughly explore the best implementation option to create an accurate and complete prisma/schema.prisma file to fully and faithfully represent the database design in the sql file generated. please plan very carefully how your will create a complete representation in your carefully implemented prisma/schema.prisma. remember to use line by line comparison so as not to miss (omit) any part of the database schema represented by the sql file created earlier.

---
awesome job! please use the same rigorous and meticulous approach to deeply and thoroughly explore for the best implementation option to create the complete updated version of the specified files in phase 3 of the comprehensive execution plan shared earlier. please carefully plan how to create the complete version of each of the files in phase 3 before proceeding cautiously. please put on your deep-thinking hat to deeply and thoroughly explore how to re-imagine the complete updated files specified in phase 3 of the comprehensive execution plan. thank you and good luck my very best coding assistant and expert in the world!

---
awesome job! please use the same rigorous and meticulous approach to deeply and thoroughly explore for the best implementation option to create the complete updated version of the specified files in phase 4 of the comprehensive execution plan shared earlier. please carefully plan how to create the complete version of each of the files in phase 4 before proceeding cautiously. please put on your deep-thinking hat to deeply and thoroughly explore how to re-imagine the complete updated files specified in phase 4 of the comprehensive execution plan. thank you and good luck my very best coding assistant and expert in the world!

---
awesome job! please put on your deep-thinking hat to deeply and thoroughly review your awesome implementation of the "re-imagined" codebase carefully and systematically. then create a complete updated replacement file for the config files mentioned in phase 1 of the comprehensive execution plan. only create complete replacement file for those files in phase 1 that need modification or updating now that the whole codebase has been completed. next help me to create a complete updated replacement file for the `README.md` for the GitHub repository. the complete updated `README.md` should accurately represent the current status of the codebase, and should be even more detailed, comprehensive and informative. please re-imagined a updated `README.md` that will create Wow effect and can instantly attract many contributors. please do your very best my absolute best coding assistant and expert in the world! thank you and good luck!

---
awesome job! please put on your deep-thinking hat to deeply and thoroughly review your awesome implementation of the "re-imagined" codebase carefully and systematically. then create a "Codebase Summary Document" with the structure and format below.

You are an expert technical writer specializing in creating comprehensive  codebase summary document that serves as living documentation for AI coding assistants. Your task is to analyze any given codebase and generate a `Codebase Summary.md` file that enables rapid onboarding and efficient development workflows.

## Analysis Process

### 1. Initial Codebase Scan
First, perform a systematic scan of the repository:

1. **Identify Entry Points**: Locate main executables (`main.py`, `app.py`, `cli.py`, etc.)
2. **Map Dependencies**: Parse `requirements.txt`, `pyproject.toml`, `package.json`, or equivalent
3. **Structure Analysis**: Create a mental model of the directory structure
4. **Technology Stack**: Identify languages, frameworks, and key libraries
5. **Configuration Files**: Note all `.env`, config files, and setup scripts

### 2. Architecture Discovery
Deep-dive into the codebase to understand:

1. **Core Components**: Identify the 3-7 main modules/components
2. **Design Patterns**: Recognize patterns (MVC, Repository, Factory, etc.)
3. **Data Flow**: Trace how data moves through the system
4. **External Integrations**: Note APIs, databases, services
5. **Key Abstractions**: Identify the most important classes/functions

### 3. Developer Experience Mapping
Focus on the developer journey:

1. **Setup Friction**: Identify all steps needed to run the project
2. **Common Tasks**: Document the 5-10 most frequent development actions
3. **Debugging Points**: Note where developers typically need breakpoints
4. **Extension Points**: Highlight how to add new features
5. **Testing Strategy**: Understand how to run and write tests

## Content Generation Rules

### Required Sections (In Order)

1. **Project Overview**
   - One-sentence elevator pitch
   - Key differentiators (what makes this special)
   - Primary use cases

2. **Quick Start**
   - Copy-pasteable setup commands
   - Minimum viable configuration
   - First successful run command

3. **Architecture**
   - High-level component diagram (ASCII or description)
   - Key design decisions and their rationale
   - Technology choices with justifications

4. **Core Components**
   For each major component (3-7 items):
   - File location with line numbers
   - Primary responsibility
   - Key classes/functions
   - Usage examples

5. **Development Commands**
   Organize by workflow:
   - Setup/Installation
   - Running locally
   - Testing commands
   - Code quality checks
   - Deployment (if applicable)

6. **Configuration**
   - Required environment variables
   - Optional configurations
   - Common gotchas
   - Security considerations

7. **File Structure**
   - Tree view of key directories
   - Mapping of files to responsibilities
   - Data/storage locations

8. **Extension Guide**
   - How to add new features
   - Common modification patterns
   - Plugin/extension architecture (if exists)

9. **Testing & Quality**
   - How to run tests
   - Test structure
   - Code style rules
   - Performance considerations

### Writing Guidelines

- **Progressive Disclosure**: Start simple, add detail progressively
- **Action-Oriented**: Every section should answer "How do I...?"
- **Concrete Examples**: Include actual commands, not descriptions
- **Cross-References**: Link concepts to specific files/lines
- **Future-Proofing**: Note where future developers might need to make changes

### Formatting Standards

- Use tables for file/component mappings
- Include line numbers for key files (`src/main.py:42`)
- Code blocks for all commands
- ASCII diagrams for architecture
- Bullet points for quick scanning

## Special Considerations

### For AI/ML Projects
- Model specifications and requirements
- Dataset locations and formats
- Training vs inference modes
- GPU/CPU requirements

### For Web Projects
- API endpoints with examples
- Database schema overview
- Frontend/backend communication
- Authentication flows

### For CLI/Tools
- All commands and flags
- Configuration file formats
- Example usage scenarios
- Output formats

### For Libraries
- Installation methods
- Basic usage examples
- API reference overview
- Common integration patterns

## Validation Checklist

Before finalizing, verify:

- [ ] Can a new developer get the project running in <10 minutes?
- [ ] Are all setup error cases documented?
- [ ] Can someone extend the project without reading source code?
- [ ] Are all external dependencies explained?
- [ ] Are testing commands copy-pasteable?
- [ ] Is the "why" behind architectural decisions clear?
- [ ] Are extension points obvious?
- [ ] Are common debugging scenarios covered?

Remember: The goal is to make the AI assistant as effective as a senior team member who already knows the codebase intimately. Every section should reduce the time between "I need to do X" and "I know exactly how to do X".
